# 2주차 발표

## 범위
1. 실행컨텍스트
2. 렉시컬환경
3. 스코프
4. 클로저

<br>

## 01. 실행컨텍스트
- 실행컨텍스트는 __자바스크립트 동작원리__ 를 담고있는 핵심 개념입니다.. 실행컨텍스트를 이해하면 스코프, 호이스팅, 바인딩, 렉시컬환경, 클로저에 대해서도 쉽게 이해할 수 있으며, 
실행컨텍스트를 생성하는 소스코드는 4가지이나 그중 2가지(전역, 함수)에 대해서만 설명 하겠습니다..

### 소스평가과정, 소스실행과정
- 평과과정: 실행컨텍스트가 생성되고 변수, 함수 등의 선언만이 이루어져 렉시컬환경에 등록된다.
- 실행과정: 선언문을 제외한 코드가 순차적으로 실행된다. 할당, 참조등이 이루어짐

### 실행컨텍스트 스택
실행컨텍스트가 생성이되면 __LIFO(Last In First Out)__ 의 특성을 지닌 스택 자료구조로 관리가 된다. 
우선 평가단계에서 전역실행컨텍스트가 생성이되고 실행단계에서 `함수호출`을 하게 되면 함수코드의 평가단계에서 `함수실행컨텍스트`가 생성되어 실행컨텍스트 스텍에 쌓이게 된다.

![실행컨텍스트](https://user-images.githubusercontent.com/89904226/143475091-db8b4273-a272-4fca-86c1-6f5bd3c0614f.png)
> 즉 실행컨텍스트의 최상단에 위치한 컨텍스트는 항상 실행중인 컨텍스트이다.

<br>

## 실행컨텍스트는 어떻게 구성되어있을까?

## 02. 렉시컬환경 
실행컨텍스트가 생성이되면 __렉시컬환경(Lexical Enviroment)__ 을 생성하게 된다. 또한 렉시컬환경에서는 `환경레코드`(Enviroment Record)를 생성하게 되는데  
이는 함수실행컨텍스트와 전역실행컨텍스트 모두 동일하며 `전역실행컨텍스트`의 경우에는 __객체 환경 레코드(Object Enviroment Record)__ 를 추가적으로 포함한다.

그림으로 보게되면 이러하다.

렉시컬환경에는 `환경레코드(Enviroment Record)`와 `외부 환경레코드 참조(Out Enviroment Record Reference`)로 이루어져 있으며 저는 이 둘을`레코드`와 `아웃`으로 지칭하겠습니다.

### 환경레코드
1. 전역환경레코드
    - `객체환경레코드`가 존재하며 객체환경 레코드에는 `Binding Record`라는 객체가 존재하며 그 안에 var로 선언한 변수, 함수선언식 등이 프로퍼티, 메소드 형식으로 존재합니다.
    - `선언환경레코드`가 존재하며 let, const등으로 선언한 변수와 변수값등이 담겨있습니다. 
      이들은 선언단계와 초기화단계가 동시에 일어나지 않고 순차적으로 일어남을 그 사이에 __변수를 참조할 수 없는 구간__ 이 존재하는데 이를 __TDZ__(Temperal Dead Zone)이라고 부릅니다.
    
    - [[GlobalThisValue]] 라는 내부슬롯이 존재하며 this가 바인딩됩니다. 일반적으로 `전역객체`가 바인딩됩니다. 이로 인해서 `객체환경레코드`의 `Binding Object`에 담긴 변수, 함수등은 전역객체의 `프로퍼티`, `메서드`가 될수 있습니다.

2. 함수환경레코드
    - 함수실행컨텍스트에서는 렉시컬환경의 `환경레코드`는 `Object Enviroment Record`를 따로 포함하지 않으며 함수의 환경레코드에는 `매개변수`, `변수`, `arguments` 등이 식별자형태로 담겨있다.
    - ThisBinding은 함수호출방식에 의해 달라지며 현재로써는 전역컨텍스트의 `전역객체`를 바인딩한다.


### 외부 렉시컬 환경 참조
실행컨텍스트의 렉시컬환경에 포함된 또하나의 부분인 외부렉시컬 환경참조에 대해 살펴보겠습니다. 현재 평가중인 실행컨텍스트가 생성된 환경인 __상위 실행컨텍스트의 렉시컬환경을__ 가리키고 있습니다.
즉 전역환경 컨텍스트에서는 상위스코프가 존재하지 않으므로 `null`을 참조하고 있습니다.

흔히 현재 실행컨텍스트의 렉시컬환경에는 존재하지 않는 변수를 참조하려고 할 때 `out`을 통해 스코프체인을 통해 상위 실행컨텍스트의 렉시컬환경을 차례대로 탐색할 수 있게 되는 경우를 생각하면 될 것입니다.

> 상위로는 참조가 가능하나 하위로는 참조가 불가능하다.

### 코드로 설명하기
```js
var x = 1;
const y = 2;

function red(a) {
  var x = 3;
  const y = 4;

  function blue(b) {
    const z = 5;
    console.log(a + b + x + y + z)
    // console.log(20 + 10 + 3 + 4 + 5);
  }
  blue(10);
}

red(20)
```

### 블록레벨스코프는 실행컨텍스트를 생성하는가?
- 실행컨텍스트를 생성하지 않으며 블록레벨의 렉시컬환경을 생성하여 블록레벨스코프의 생명주기가 다하기 전까지 __상위 렉시컬환경을 대체__ 하며 생명주기가 다하게되면 다시 되돌아간다.
- 일시적으로 덮어씌워진다고 생각하면 이해하기 편하다.

<br>


## 03. 스코프란?
`Scope`를 직역하면 범위, 영역 이라는 뜻입니다. 즉 __식별자가 유효한 범위__ 를 말합니다.

```js
var x = 'global';
​
function foo() {
  var x = 'local';
  console.log(x)
}
​
foo(); // local
console.log(x);  //global
```
- x 라는 변수를 전역과 함수내부에 각각 선언을 해준 후 다른값을 할당해줌
- 각각의 전역스코프, 함수스코프를 가짐

즉 스코프란 자바스크립트에서 식별자가 검색가능한 범위를 말합니다.


### 3-1. 스코프의 종류
- 전역스코프: 가장 최상위스코프 , 어디서든지 참조가능하다는 특징이 있다.
- 지역스코프  함수 코드블록 내부의 스코프(유효범위)를 의미하며 내부함수 -> 외부함수만 참조가능하다.


### 3-2 스코프체인이란?
__스코프체인__ 은 모든 스코프들이 하나의 __계층적 구조__ 로 연결된 것을 말한다.  
변수를 참조할 때 자바스크립트 엔진은 하위(내부)스코프에서 상위(외부)스코프로의 탐색을 허용한다.

![체인스코프](https://user-images.githubusercontent.com/89904226/143475422-120671ae-2e3d-4bc8-915c-fec9d0209ee7.png)


### 3-3 함수레벨 스코프, 블록레벨 스코프
__함수레벨 스코프__ 와 __블록레벨 스코프__ 는 `함수`의 코드블록이냐 함수가 아닌 다른 `문(if, for)`의 코드블록이냐에 따라 분류하게 됩니다.

`var`, `let`, `const`등 변수를 선언할 때 키워드를 어떤걸 사용하냐에 따라 해당 스코프를 지원하느냐 안하느냐의 차이를 띄고 있습니다.

```js
var x = 1;

if(true) {
  var x = 10;
}

console.log(x) // 10
```

- 이 경우 `var`는 함수레벨스코프 만을 지원하고 `if`는 함수가 아니므로 현재 스코프는 `전역스코프`만이 존재합니다.

```js
let x = 1;

if(true) {
  let x = 10;
}

console.log(x) // 1
```
- 이 경우에는 `let` 키워드를 사용했음으로 `if문`의 블록스코프가 형성되어 전역과 블록의 스코프에는 각각 다른 `x`라는 변수가 존재합니다.


### 3-3 렉시컬스코프: 함수는 어떤 환경에 따라 스코프가 결정될까?
- 동적스코프: 함수의 실행시점에 따라 상위 스코프를 결정
- 정적스코프(렉시컬스코프): 함수의 선언시점에 따라 상위스코프를 결정

> 실행컨텍스트에서의 코드와 유사하지만 함수 선언시점이 다른 코드
```js
var x = 1;
const y = 2;

function red() {
  var x = 3;
  const y = 4;

  blue(10);
}

function blue(b) {
  const z = 5;
  console.log(b + x + y + z)
  // console.log(20 + 10 + 3 + 4 + 5); -> (20, 10 + 1 + 2 + 5)
}

red()
```
#### 정답
- 자바스크립트는 __정적스코프(렉시컬스코프)__ 를 따른다.
- 즉 실행컨텍스트가 생성될 때 외부렉시컬 환경참조도 결국 정적스코프를 따른다.

<br>

## 04. 클로저
클로저는 자바스크립트의 고유개념이 아니며 함수를 `일급 객체`로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

> "클로저는 함수와 그 함수가 선언된 렉시컬환경의 조합이다." - MDN

```js
const x = 1;

function outerFunc() {
  const x = 10;
  // 중첩함수, 클로저
  var innerFunc = function () {
    console.log(x);
  }

  return innerFunc
}

let inner = outerFunc();
inner(); // 10
```

![클로저 호출스택 before](https://user-images.githubusercontent.com/89904226/143475307-e655f0ed-f387-4087-837a-5cad75d08ec6.png)

![클로저 호출스택 after](https://user-images.githubusercontent.com/89904226/143475318-fd1cc17b-af7a-4f54-b2d5-78ac027f2bc5.png)

실행컨텍스트 관점에서 보게된다면 스코프의 실체는 결국 실행 컨텍스트의 `렉시컬 환경`이다.

### 4-1 함수 객체의 내부슬롯 [[Environment]]
렉시컬 스코프가 가능하려면 함수가 선언될 때의 환경의 스코프, 즉 현재 실행중인 환경의 스코프에 대한 정보를 기억해야한다. 이를 위해서 함수는 자신의 내부슬롯 [[Environment]] 에 `현재 실행중인 렉시컬 환경 참조` 를 저장한다. 이는 함수가 호출이 되었을 때 함수의 `외부 렉시컬 환경 참조(outer)`에 저장될 참조값이기도 하다.

### 4-2 그래서 클로저가 뭐지?
즉 클로저는 함수가 정의될 때의 실행컨텍스트의 렉시컬환경의 참조를 `내부슬롯`에 기억하고 있는 함수이며, 동시에 외부함수의 생명주기가 다하여 실행컨텍스트 스택에 외부함수가 존재하지 않음에도 그 외부함수의 렉시컬환경을 기억하고 있어 참조할 수 있는 함수이다.

`외부함수가 생명주기가 다해 종료가 되었음에도 내부함수에서 외부함수의 지역변수 등에 접근할 수 있는 함수를 클로저(closure)라고 한다.`
















