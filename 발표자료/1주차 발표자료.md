# 자바스크립트 Deep Dive Study 1주차

### 챕터

> 4(변수), 5(표현식과 문), 6(데이터 타입), 7(연산자), 10(객체 리터럴), 11(원시값과 객체의비교)

<br>

# 1. 변수
## 1.1 변수란?
  - 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
  - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 메모리 공간에 저장된 데이터를 식별할 수 있는 고유한 이름을 __변수명(식별자)__, 변수에 저장된 값을 __변수 값__ 이라고함.
  - 변수에 값을 저장하는 것을 __할당(대입,저장)__ 이라고 하고, 저장된 값을 읽어 들이는 것을 __참조__ 라 한다.

## 1.2 변수의 필요성
- 컴퓨터는 데이터를 메모리 셀에 저장하고 CPU를 통해 연산을 진행
- 연산의 결과값 또한 메모리에 공간을 확보하여 저장
- 결과값을 재사용하기 위해서는 메모리주소에 직접 접근해야함 (에러를 발생시키는 요인)
- 또한 결과값의 메모리 주소는 프로그램을 실행할 떄 결정됨으로 예측할 수 없음
- 이 때 __변수__ 라는 개념을 이용하게 된다면 이러한 데이터들을 재사용 할 수 있는 효과가 있음.

## 1.3 변수선언, 할당
- 변수는 선언과 할당이 존재한다.
```js
// 선언
var score; 

// 할당
score = 100;

// 선언 , 할당
var test = 10;
```
 ### 1.3.1 변수선언
- 변수를 생성하는것을 뜻함
- 값을 저장하기위해 메모리 주소를 확보, 변수명과 메모리주소를 연결하여 값이 저장되도록 준비하는 과정
- `var`, `let`, `const` 키워드를 사용하여 선언할 수 있음
 ### 1.3.2 변수값 할당
- 할당 연산자 (=) 를 사용하여 연산자 우변의 값을 좌변의 변수에 할당해주는 것을 말함
- 변수선언과 값의 할당을 한줄의 코드로 작성해도 각각 선언과 할당으로 나누어서 실행함
- 변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우는 것이 아님 
-  새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장
## 1.4 선언 실행시점과 호이스팅
 ### 1.4.1 선언 실행시점
 ```js
console.log(test); // undefined
var test = '변수선언문'; 

console.log(testFunc()) // '함수선언문'

function testFunc() {
  return '함수선언문'
}
```

- `var` 의 경우  `undefined`를 반환
- 이는 변수선언이 소스코드가 한 줄 씩 순차적으로 실행되는 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문
- `console.log(testFunc())` 은 `testFunc is not defined`가 아닌 return 값을 출력해줌
- 자바스크립트 엔진은 소스코드를 실행하기 전 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 면저 실행

 ### 1.4.2 호이스팅
 - `var`, `let`, `const`, `function`, `class` 키워드를 사용하는 선언문이 __코드의 제일 위__ 로 끌여올려지는 듯한 현상
- `let`, `const`, `class`는 호이스팅이 일어나지 않는다고 생각하기 쉽지만 그렇지않음(2주차에 학습예정)

<br>

# 2. 데이터타입
## 2.1 데이터 타입이란?
  - 데이터 타입이란 값의 종류이다.
  - 자바스크립트는 총 7가지의 데이터 타입을 제공한다.
  - 7가지 데이터 타입은 2가지[원시타입, 객체(참조)타입]으로 분류된다.
>  데이터 타입의 분류
> - 원시타입: [number, string, boolean, undefined, null, symbol]<br>
>  - 객체타입: [object, function, array, ...] 

<br>

## 2.2 데이터 타입의 필요성

  ### 1. 데이터 타입에 의한 메모리 공간의 확보와 참조
  - 자바스크립트에서는 데이터 타입에 따라 정해진 메모리공간을 __확보__ 한다.
  - __참조__ 시 데이터 타입에 따라 한번에 읽어들일 메모리 셀의 개수를 알아야 한다.
  ### 2. 데이터 타입에 의한 값의 해석
  - 데이터 타입에 따라 읽어들인 2진수를 다르게 해석한다.
  - 이는 데이터의 저장값이 2진수(숫자)이기 때문에 가능한 현상이다.
  ### 3. 데이터 타입이 필요한 이유 정리
  1. __저장__ 시 확보할 메모리 셀의 개수를 결정하기 위해 
  2. __참조__ 시 한번에 읽어들일 메모리 셀의 개수를 결정하기 위해
  3. __해석__ 시 2진수를 어떻게 해석할지 결정하기 위해

<br>

## 2.3 데이터 타입의 종류와 분류
  ### 1. 숫자타입(number)  
  - 자바스크립트에서의 number는 정수만을 위한 타입이 없이 모든 숫자를 포함
  - 값을 참조시 진수에 상관없이 모두 10수로 처리함
  ### 2. 문자열 타입(string)
  - 텍스트 데이터를 나타내는데 사용할 수 있음
  - UTF-16의 집합으로 전 세계 대부분의 문자를 표현할 수 있음.
  - 문자열은 작은따음표(''), 큰따음표(""), 백틱(``)으로 텍스트를 감쌀 수 있음

  > 따음표로 문자를 감싸주지 않으면 그것을 식별자나 키워드로 인식하는 문제가 발생한다.
  
  #### 2-2-1. 템플릿 리터럴
  - ES6부터 지원하는 새로운 문자열 표기법
  - 백틱(``)을 통해 문자열을 감싸줌으로 [멀티라인 문자열, 표현식삽입, 태그드템플릿]을 지원함
  ```js
  // 1. 멀티라인 문자열
  var str = `이 줄 다음은 줄바꿈됩니다.
  짜잔`;
  // 1-1. 멀티라인 문자열이 없을 경우 이스케이프 시퀸스를 사용해야한다. (\)
  var str = "이 줄 다음은 줄바꿈됩니다.\n 짜잔"

  // 2. 표현식 삽입: ${}로 표현식을 감싸준다.
  var first = 'yeongmin'
  var last = 'ahn'

  console.og(`${first} ${last}`) // yeongmin ahn

  // 3. 태그드템플릿
  // 잘 이해가 가지않음으로 추가적인 학습필요
  ```
  ### 3. 불리언 타입(boolean)
  - 논리적 참, 거짓을 타나내는 `true`와 `false`값 뿐이다.
  ```js
  var dataType = true;

  console.log(typeof(a)); // 'boolean'
  ```
  ### 4. undefined
  - undefined 타입의 값은 `undefined` 하나이다.
  - `var`로 선언된 변수는 암묵적으로 `undefined`로 __초기화__ 된다.

  ### 5. null
  - null 타입의 값은 `null`이 유일하다.
  - 변수에 값이 없다는 것을 명시적으로 나타내기 위해 사용한다.
  > 대부분의 함수는 `undefined`를 반환하지만 `document.qeurySelector`의 경우에는 `null`을 반환한다.

  ### 6. 심벌타입(Symbol)
  - ES6에서 추가된 7번째 타입
  - 변경 불가능한 원시타입의 값
  - 객체의 유일한 프로퍼티 키를 만들기 위해 사용하곤 함
  - 리터널({})로 생성하지 않고 `Symbol function`으로 호출해 생성하는 것이 특징
  - 외부에 노출되지 않으며 , 어떤 다른값과 중복되지 않는 유일무이한 값
  ```js
  // 심벌 갑 생성
  var key = Symbol('key');
  console.log(typeof key); // symbol

  // 객체를 생성한다.
  var obj = {};

  // 생성한 symbol을 객체의 유일한 프로퍼티 키로 사용
  obj[key] = value;
  console.log(obj[key]); // value
  ```
  
## 2.4 동적타입 언어의 문제점과 해결방안
  ### 동적타입 언어의 문제점 
  - 자바스크립트는 개발자의 의도와 상관없이 엔진에 의해 타입이 자동적으로 변환되기도 한다.
  - 유연성(flexbillity)은 높지만 신뢰성(reliabilty)은 낮다.
  
  ### 동적 타입 언어의 문제점을 줄이기 위한 방안
  1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
  2. 변수의 유효범위(스코프)를 최대한 좁게 만든다.
  3. 전역변수는 최대한 사용을 지양한다.
  4. 변수보다는 상수를 사용해 값의 변경을 억제한다 (const를 사용하자.)
  5. 변수명은 변수의 목적,의미를 파악할 수 있도록 작성하자.

<br>

# 3. 객체리터럴
## 3.1 객체란?
  - 원시값과는 달리 객체는 __변경 가능한 값__ 이다.
  - 0개 이상의 __프로퍼티__ 로 구성된 집합이다.

<br>

## 3.2 객체의 구성
  ### 3.2.1 프로퍼티(property)
  - 객체는 프로퍼티의 집합이며, 프로퍼티는 key, value값으로 구성된다.
  - 프로퍼티 키는 프로퍼티 값에 접근할 수 있는 식별자 역활을 한다.
  ### 3.2.2 프로퍼티 key
  #### 식별자 규칙에 따른 프로퍼티 키
  - 식별자 규칙을 따른 경우에는 따옴표를 생략할 수 있다.
  - 식별자 규칙을 따르지 않은 경우에는 따옴표를 작성해줘야한다.
  ```js
  const person = {
    firstName: 'yeong-min', // 식별자 규칙을 따른 프로퍼티 키
    'last-name': 'ahn' // 식별자 규칙을 따르지 않은 프로퍼티 키,
  }
  ```

  #### 표현식을 사용해 key생성하기
  - [표현식]을 통해 프로퍼티 키를 동적으로 생성할 수 있다.
  ```js
  const obj = {};
  const key = 'hello';

  // ES5: 프로퍼티 키 동적 생성
  obj[key] = 'world';
  // ES6: 계산될 프로퍼티 이름
  const obj = { [key] : 'world' };
  ```

  #### 숫자형을 key, value값으로 사용했을 경우
   - 프로퍼티의 key로 숫자형을 사용하게 되면 key값이 문자열로 변환된다.
  ```js
  const foo = {
    0: 1,
    1: 2,
    2: 3
  };

  console.log(foo) /// { '0': 1, '1': 2, '2': 3 }
  ```

  #### key값이 중복되게 할당한 경우
  - 나중에 선언한 프로퍼티가 기존의 프로퍼티를 덮어쓴다.
  ```js
  const foo = {
    name: 'Lee',
    name: 'Kim'
  }

  console.log(foo); // {name: 'Kim}
  ```

  > 권장하지 않는 키 생성방법 : 예약어를 사용하는것, 빈문자열로 사용하는하는것


  ### 3.2.3 메서드(method)
  - 자바스크립트 함수는 일급 객체이다.
  - 함수를 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.
  - 프로퍼티값이 함수일 경우에는 메서드라고 부른다.
  ```js
  const circle = {
    radius: 5, // <- 프로퍼티

    // 원의 지름
    getDiameter: function () { // 메서드
      return 2 * this.radius; // this는 circle을 가리킴
    }
  };

  console.log(circle.getDiameter()); // 10
  ```

  ### 3.2.4 프로퍼티 접근, 갱신, 동적생성
  1. 마침표 표기법: object.key
  2. 대괄호 표기법: object["key"]
  - 접근을 통해 값을 할당해주면 __갱신__ 이 된다.

  - 존재하지 않는 프로퍼티에 값을 할당하면 자동으로 프로퍼티가 __동적 생성__ 된다.
  
  - `delete`연산자를 통해 객체의 프로퍼티를 __삭제__ 한다.
  ```js
  const parson = { name: 'Ahn' };

  // 접근
  console.log(parson.name); // Lee
  console.log(parson["name"]); // Lee

  // 갱신 
  parson.name = 'Kim';
  console.log(parson.name) // Kim

  // 동적생성
  parson.age = 27;
  console.log(parson.age) // 27

  // 삭제
  delete person.age;
  console.log(person) // {name: "Kim"}
  ```

<br>

## 3.3 객체리터럴에 의한 객체 생성
  - 객체를 생성할 수 있는 방식은 여러개가 있다.
  ```js
  // 객체 생성 방식

  // 1.객체 리터럴: 중괄호({ ... }) 내에 0개 이상의 프로퍼티를 정의
  const empty = {};

  // 2.Object 생성자 함수: new 키워드를 사용
  const person = new Object();
  person.name = 'ahn';

  // 3.생성자 함수 : 기존 함수에 new 연산자를 붙여서 호출
  // 인스턴스를 생성하기 전에, 먼저 비어있는 객체를 생성한다.
  function Person(name) {
    this.name = name;
  }

  const person1 = new Person('ahn');
  const person2 = new Person('kim');

  // 4. Object.create 메서드: 3주차 프로토타입부분에서 학습을 진행할 예정
  // 5. 클래스(ES6): Prototype을 공부하면 클래스는 공짜라고 들었다.
  ```
  > 코드블록의 중괄호 뒤에는 세미클론(;)을 붙이지 않는다.
  
<br>

## 3.3 ES6에서 추가된 객체 리터럴의 확장기능
  ### 1. 프로퍼티 축약 표현
  - 프로퍼티의 값은 식별자일수 있다.
  - 프로퍼티의 key 와 value 가 동일한 값인 경우 value를 key를 생략할 수 있다.
  ```js
  const x = 1, y = 2;

  const obj = { x, y };
  
  console.log(obj) // {x: 1, y: 2};
  ```

  ### 2. 계산된 프로퍼티 이름
  - 표현식을 사용하고 있는 템플릿 리터럴을 대괄호([...])로 감싸준 것을 계산된 프로퍼티 이름이라고 한다.
  - 계산된 프로퍼티 이름을 통해 프로퍼티 key 값을 동적생성해줄 수 있다.
  ```js
  const prefix = 'prop'
  let i = 0;

  const obj = {
    [`${preifx}-${++i}`]: i,
    [`${preifx}-${++i}`]: i,
  }
  ``` 

  ### 3. 메서드 축약표현
  - 메서드를 정의할 떄 function 키원드르 생략한 축약표현이 가능하다.
  ```js
  const obj = {
    name: 'Lee',
    sayHi() {
      console.log('Hi ' + this.name);
    }
  }

  obj.sayHi(); // Hi! Lee
  ```
<br>

# 4. 연산자
## 4.1 삼항 조건 연산자
  - 조건식의 평가 결과에 따라 값을 결정
  - `조건식 ? true일 때 반환값 : false 일때 반환값`

### 4.1.1. 삼항 조건 연산자와 if ... else의 차이점
  - 삼항조건연산자는 그 자체가 값이 될 수 있다.
  - if ... else 문은 문(statement)이기 때문에 값처럼 사용이 불가능하다.
  - 삼항조건연산자는 변수에도 할당을 할 수 있으며 함수의 인자로도 전달해 줄 수 있다.

### 4.1.2. 삼항 조건 연산자의 중첩
  - if ... else 문과 동일하게 중첩이 가능하다.
  ```js
  let a = -1;
  // 삼항조건연산자의 중첩
  // 조건문 ? true 값 : 조건문 ? true 값 : false 값
  let answer = a > 10 ? "10보다크다" : a > 0 ? "0보다는 크다" : "0보다 작다";

  // 함수의 매개변수로 전달이 가능
  function solution(answer) {
    return '반환된 값:' + answer 
  }

  console.log(solution(answer))
  ```
  > 삼항조건 연산자의 너무 많은 중첩은 가독성 측면에서 if ... else문 보다 불리하다.

<br>

# 논의해보고 싶은 부분

- ES6 -> ES7 -> ES8 표준스펙이 추구하는 방향은 무엇일까?

- 비교연산자 대신 Object.is 메서드를 사용하는것이 가장 좋은 것이 아닌가?

- 삼항조건 연산자는 어떨 때 사용을 지양하는 것이 좋을까?

- 가독성이 좋은 코드만이 진정으로 좋은 코드일까?

- 목적과 의미를 드러내는 변수명은 어떻게 짓는 것이 좋을까?

- 태그드 템플릿 사용법



