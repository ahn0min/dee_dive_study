## 스코프(Scope)란?
​
`Scope`를 직역하면 **범위, 영역** 이라는 뜻입니다. 즉 자바스크립트에서의 스코프는 **식별자(변수, 매개변수, 함수)가 유효한 범위** 를 말합니다.  
이 스코프(유효범위)는 함수, 변수등이 선언되는 환경을 기반으로 합니다. 코드를 예로 들겠습니다.
​
```
var x = 'global';
​
function foo() {
  var x = 'local';
  console.log(x)
}
​
foo();
console.log(x);
```
​
이 때 `x`라는 변수는 코드의 가장 바깥쪽 환경과 함수 내부에서 각각 선언을 해주고 값을 다르게 한다음 호출을 해주었다.  
그렇게 되면 자바스크립트 엔진에서 스코프를 통해 어떤 변수를 참조해야할지 결정한다. 그러므로 **스코프** 란 **식별자를 검색할 때 사용하는 규칙** 이라고도 이해할 수 있으며 해당 변수가 어디에서 실행이되며 주변에 어떤 코드들이 존재하는지에 따라 다른 결과를 출력합니다.
​
> "코드가 어디서 실행되며 주변에 어떤 코드가 있는지?" 즉 코드의 문맥을 `렉시컬환경`이라고 부릅니다. 그 `렉시컬환경`으로 이루어진 것이 `실행컨텍스트`입니다.
​
즉 각각의 `x` 변수는 각각 **전역 스코프** 와 **foo 함수 스코프** 를 가짐으로 이러한 결과가 출력이 됩니다.
​
```
// local
// global
```
​
## 스코프(Scope)는 왜 존재하는가?
​
-   스코프가 존재하지 않는다면 변수명이 같은 변수가 2개 이상 존재하는 경우 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다.
-   즉 식별자는 고유한 이름으로써 어떤 값을 구별할 수 있어야하지만 식별자의 기능이 없어지게 되는 것이다.
​
## 2\. 스코프의 종류
​
코드는 `전역(global)` 과 `지역(local)`으로 나눌 수 있다. 우리는 그렇기 때문에 전역스코프, 전역변수, 지연스코프, 지역변수라고 부른다.
​
### 2-1. 전역(global)의 특징
    - 전역변수는 어디서든지 참조가 가능하다.(로컬 스코프에서도 가능)
### 2-2. 지역(local)의 특징
    - 지역이란 __함수 몸체 내부__ 를 말합니다. 
    - 지역변수는 자신이 선언된 스코프와 하위 스코프(중첩, 내부 함수)에서만 참조할 수 습니다.
    - 즉 일반적으로 __글로벌 스코프__ 에서는 __로컬 스코프__의 로컬변수를 참조할 수 없습니다.
​
### 03. 스코프체인
- 함수 몸체 내부에서 정의한 함수를 '중첩함수'라고 한다.
- '중첩함수'를 포함하는 함수를 '외부함수'라고 한다.
- 함수를 중첩할 수 있다는 것은 스코프도 중첩할 수 있다는 말이다.
- 즉 스코프는 __함수의 중첩에 의해 계층적인 구조__ 를 갖는다.
​
(하위) 내부함수 스코프 -> 외부함수 스코프 -> 전역스코프 (상위)
​
이처럼 모든 스코프들은 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 모든 스코프들이 연결된 것을 __스코프 체인__ 이라고 명칭한다. 
​
__변수를 참조할 때 자바스크립트엔진은 변소를 참조하는 스코프에서 시작하여 상위 스코프로 선언된 변수를 검색한다.__
즉 상위스코프에서 생성된 변수는 하위스코프에서 참조가 가능하다.
​
- 스코프체인은 물리적으로 존재하며, 자바스크립트 엔진은 코드를 실행함에 앞서 자료구조인 렉시컬 환경(Lexical Environment)을 실제로 생성한다. 
- 변수선언이 실행되면 변수 식별자가 렉시컬환경에 키(key)로 등록되고 
- 변수할당이 일어나면 렉시컬환경의 변수 식별자에 해당하는 값을 반환한다.
> 즉 스코프체인은 스코프들이 단반향으로 연결되어 있는 것이다. 만일 양방향으로 참조가 가능하다면 무한 탐색이 이어질 것이다..
​
​
#### 3-1. 스코프체인에 의한 함수 검색
`test`라는 함수가 전역과 지역의 중첩함수로 동시에 존재하는 경우에는 런타임이전에 함수객체가 먼저 생성됨으로 test2()에서 test()를 호출하게 될 경우 해당 로컬스코프에서의 test()함수를 실행하게 되고 'local'이라는 결과값을 출력해 주게 된다.
```js
// 전역함수
function test() {
  console.log('global')
}
​
function test2() {
  // 중첩 함수
  function test() {
    console.log('local')
  }
  test()
}
// 함수 호출
test2() // -> local
```
​
### 04. 함수 레벨 스코프
지역은 함수 내부를 말하고 지역은 지역스코프를 생성한다. 즉 __지역스코프는 함수에 의해서만 생성__ 이 된다.
`var`키워드로 선언된 변수는 `let, const`와 달리 __함수 내부몸체(코드블록)만을 지역 스코프로 인정__ 한다.
이를 __함수 레벨 스코프__ 라고 한다.
​
즉 `var` 키워드로 생성된 변수가 if문안에 동시에 존재할 경우 모두 전역변수임으로 변수값이 변경되는 부작용이 있을 수 있다.
```js
// 전역변수 x
var x = 3;
​
if (true) {
  // 전역변수 x 중첩 변수값이 재할당된다.
  var x = 10;
}
​
console.log(x) // 10
```
예제 2) `var` 키워드르 사용하여 __함수 레벨 스코프__ 만을 지원하는 경우
``` js
var i = 10;
​
for (var i = 0; i < 5; i++) {
    console.log(i) // 0 1 2 3 4
}
​
console.log(i) // 5
```
for문은 함수가 아님으로 __함수 레벨 스코프__ 를 생성하지 않기 때문에 `i`는 전역변수로 선언이 된다. 그럼으로 모두 같은 전역변수`i`를 출력하고 있다.
​
예제 3) `var`가 아닌 `let`키워드를 사용하여 __블록 레벨 스코프__ 를 지원하는 경우
```js
let i = 10;
​
for (let i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
​
console.log(i) // 10
```
`var` 키워드를 사용하여 전역변수로 선언되는 경우와 다르게 `let`의 경우 `i` 변수를 블록레벨스코프를 통해 지역변수로 선언해주기 때문에 `i` 값이 다르게 출력이 되는 것을 볼 수 있다.
​
​